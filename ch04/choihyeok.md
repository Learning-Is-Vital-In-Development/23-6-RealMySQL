# 4. 아키텍처

생성일: 2023년 4월 16일 오전 10:38

# 1. MySQL 아키텍처

### **MySQL 서버**

<aside>
💡 MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분된다

</aside>

- MySQL은 대부분 프로그래밍 언어로부터 접근 방법을 모두 지원한다.(JDBC, ODBC 등)
- _프로세스 기반이 아닌_ **스레드 기반 동작**
  - 포그라운드 스레드(사용자 스레드, 클라이언트 스레드?)
    - 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
    - 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재
    - 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져옴
    - 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업 처리
  - 백그라운드 스레드(대부분 InnoDB가 여러 작업을 백그라운드로 처리)
    - 로그 스레드
    - 읽기 스레드: 읽는 작업은 클라이언트 스레드에서 처리되기에 많은 설정 필요 없음
    - 쓰기 스레드: 아주 많은 작업을 백그라운드에서 처리하기에 충분히 설정해야 함

### **MySQL 엔진**

- 요청된 SQL 문장을 분석하거나 최적화함
- 구성요소: SQL 인터페이스, SQL 파서, SQL, 옵티마이저, 캐시&버퍼, 커넥션 핸들러
- 표준 SQL 문법 지원: 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환되어 실행 가능

### **스토리지 엔진**

- 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어옴
- **플러그인 스토리지 엔진 모델(MySQL의 독특한 구조)**
  - MySQL은 이미 많은 스토리지 엔진을 가지고 있지만, 세상의 모든 요구사항에 만족하기 위해 직접 스토리 엔진을 개발하는 것도 가능
- **컴포넌트**
  - MySQL 8.0부터 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처를 지원함. 플러그인 아키텍처의 단점을 보완함
    - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리 통신 불가
    - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
    - 플러그인은 상호 의존 관게를 설정할 수 없어 초기화가 어려움

**구성요소**

- MyISM
  - MySQL 의 기본 스토리지 엔진
  - 인덱싱, 압축, 공간 함수 등 여러 유용한 기능을 제공
  - Table lock 사용하여 트랜잭션이나 Row 수준의 잠금을 지원하지 않기 때문에 InnoDB보다 심플하고 기본적으로 빠르지만 동시성 제어가 어렵다는 단점이 있음
  - Read 쿼리가 많은 DW 환경에서 많이 사용됨
- InnoDB
  - 트랜잭션을 처리하기 위해 고안됨
  - 대부분의 경우 롤백되지 않고 완료되는(즉 정상 종료되는) 짧은 트랜잭션이 많은 경우를 처리하기 좋게 되어 있음
- Memory
  - 글로벌 메모리 영역
    - MySQL 서버가 시작되면서 운영체제로부터 할당됨
    - 클라이언트의 스레드 수와 무관
    - 대표적인 글로벌 메모리 영역은 테이블 캐시, innoDB 버퍼 풀, innoDB 어댑티브 해시 인덱스 등이 있다.
  - 로컬 메모리 영역(세션 메모리 영역)
    - MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
    - 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.
    - 대표적인 로컬 메모리 영역은 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼가 있다.

> **MySQL 서버에서 MySQL 엔진은 하나이지만, 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.**

CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB
→ CRUD 작업 발생 시 InnoDB 스토리지 엔진이 담당.

>

### **핸들러 API**

핸들러 요청: MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 스토리지 엔진에게 하는 요청

핸들러 API: 핸들러 요청에 사용되는 API

- MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.

### 쿼리 실행 구조

1. **쿼리 파서**

사용자의 요청으로 들어온 쿼리 문장을 `토큰`으로 분리해 트리 형태의 구조로 만들어 내는 작업

문법 오류는 이 과정에서 발견됨

1. **전처리기**

파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 파악

각 토큰을 테이블 이름, 칼럼 이름, 내장 함수같은 개체와 매핑하여 해당 각체의 존재 여부와 접근 권한 확인

1. **옵티마이저**

사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정(DBMS의 두뇌)

1. **실행 엔진**

만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

> 예를 들어 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정했을 경우,

1. 실행 엔진이 핸들러에게 임시 테이블을 만들라 요청
2. 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
   >
6. **핸들러(스토리지 엔진)**

MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 담당

MyISAM 테이블을 조작할 경우 핸들러가 MyISAM 스토리지 엔진과 연결되고, InnoDB 테이블을 조작할 경우 InnoDB 스토리지 엔진과 연결됨

### 쿼리 캐시

SQL의 실행 결과를 메모리에 캐시하면 매우 빠른 성능을 얻을 수 있으나 데이터 변경 시 연관된 캐시들이 삭제되기에 오히려 동시 처리 성능 저하 유발

결국 MySQL 8.0부터 쿼리 캐시는 MySQL 서버의 기능에서 완전히 제거됨

### 스레드 풀

MySQL 서버 엔터프라이즈 에디션은 스레드 풀 기능이 내장되지만, MySQL 커뮤니티 에디션은 지원하지 않음

스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적이다.

### 트랜잭션 지원 메타데이터

**데이터 딕셔너리 or 메타데이터:** 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보

옛날엔 파일 기반 관리 → 트랜잭션 지원을 안 하기에 테이블이 자주 깨짐

MySQL 8.0부터 메타데이터를 모두 InnoDB의 테이블에 저장함

시스템 테이블과 데이터 딕셔너리 정보도 모두 mysql.ibd 이름의 테이블스페이스에 저장됨(수정하지 못하게 하도록 테이블 목록 조회시 보이진 않음)

# 2. InnoDB 스토리지 엔진 아키텍처

InnoDB

- MySQL 스토리지 엔진 중 가장 많이 사용됨
- 유일한 레코드 기반의 잠금 제공
- 높은 동시성 처리 가능, 성능 뛰어남

### Primary key에 의한 클러스터링

- InnoDB의 모든 테이블은 primary key를 기준으로 순서대로 클러스터링되어 저장됨
- 모든 세컨더리 인덱스는 primary key의 값을 논리적인 주소로 사용
- primary key == 클러스터링 인덱스
- MyISAM 스토리지 엔진은 클러스터링 키를 지원하지 않음

### foreign key 지원

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능(MyISAM나 MEMORY 테이블에선 사용 불가)
- foreign key는 데이터베이스 서버 운영의 불편함이 존재함
- 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 함
- InnoDB에서 foreign key는 부모와 자식 테이블 모두 해당 칼럼에 인덱스이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다

### MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기 제공
- InnoDB는 Undo log를 이용해 이 기능을 구현함
  - MySQL 서버의 시스템 변수(transaction_isolation)에 설저왼 격리 수준에 따라 READ_UNCOMMITTED인 경우 버퍼에서 읽고, READ_COMMITTED 이상일 경우 언두 로그에서 읽는다.
  - Commit되면 버퍼에 영구적인 데이터로 만들고, 롤백되면 언두 영역에 있는 데이터를 버퍼 풀로 다시 복구함

![E9784897-EEB0-4B4D-9843-7405B9F41AF1.jpeg](4%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5%206a553b828f654045a28536ed6263e674/E9784897-EEB0-4B4D-9843-7405B9F41AF1.jpeg)

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

InnoDB 스토리지 엔진은 `MVCC 기술`을 이용해 잠금을 걸지 않고 읽기 작업을 수행하기에 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능하다.(격리 수준 SERIALIZABLE 제외)

### 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리함

InnoDB의 `데드락 감지 스레드`는 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아 그중 하나를 강제 종료한다.

일반적으로 데드락 감지 스레드는 자원 소모가 덜하지만, 동시 처리 스레드가 매우 많아지거나, 데드락 개수가 많아지면 많은 CPU자원을 소모할 수 있다.
→ MySQL 서버는 innodb_deadlock_detect 시스템 변수 off시 데드락 감지 스레드는 작동하지 않는다.

### 자동화된 장애 복구

InnoDB는 손실이나 장애로부터 데이터를 보호하기 위한 여러 매커니즘이 탑재돼 있다. → 완료하지 못한 트랜잭션이나 데이터 페이지 등에 대한 복구 작업이 자동으로 진행된다.

만약 서버와 무관하게 디스크나 하드 이슈로 자동 복구를 못 하는 경우, MySQL 서버의 설정 파일에 innoDB_force_recovery 시스템 변수를 설정해 서버를 다시 시작해야 한다.

innoDB_force_recovery 값은 1~6까지 있다.

### InnoDB 버퍼 풀

InnoDB 스토리지 엔진의 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.

쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.

MySQL 5.7 버전부터 InnoDB 버퍼 풀을 동적으로 조절할 수 있게 개선됐다.

- 버퍼 풀 구조
  - InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 스토리지 엔진이 데이터를 필요로 할 때 해당 페이지를 읽어 각 조각에 저장한다.
  - LRU(Least Recently Used) 리스트, flush 리스트, Free 리스트라는 3개의 자료 구조를 관리한다.
  - LRU 리스트
    - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이 목적이다.
  - flush 리스트
    - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리함
    - 일단 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크에 기록된다.
  - Free 리스트
    - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
    - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
- 버퍼 풀과 리두 로그
  - 버퍼 풀은 디스크에서 방금 읽어 변경이 없는 클린 페이지부터 CUD 명령으로 변경된 데이터를 가진 더티 페이지를 가지고 있다. 더티 페이지는 버퍼 풀에 무한정 머무를 수 없기에, 리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용된다.
- 버퍼 풀 플러시
  InnoDB 스토리지 엔진은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음 2개의 플러시 기능을 백그라운드로 실행한다. - 플러시 리스트 플러시 - 리두 로그 공간을 재활용하기 위해 더티 페이지가 먼저 디스크로 동기화돼야 한다. 이를 위해 플러시 리스트 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다. - 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크에 기록하느냐가 쿼리 성능을 좌우한다. - LRU 리스트 플러시 - LRU 리스트 플러시 함수를 통해 사용 빈도가 낮은 데이터 페이지들을 제거해 새로운 페이지들을 읽어올 공간을 만든다.
- 버퍼 풀의 적재 내용 확인
  - MySQL 서버의 information_schema 데이터베이스의 innodb_cached_indexes 테이블로 테이블의 인덱스별 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인 가능

### Double Write Buffer

InnoDB 스토리지 엔진의 리두 로그는 변경된 내용만 디스크에 기록하기에 플러시할 때 일부만 기록되면 그 페이지의 내용을 복구할 수 없다.(partial-page)

이 문제를 막기 위해 Double-write 기법을 사용한다.

### Undo log

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 CUD 변경 이전의 데이터를 별도로 백업한다. 이렇게 백업된 데이터가 Undo log이다.

- 트랜잭션 보장
  - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 되기에 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.
- 격리 수준 보장
  - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어 반환하기도 한다.

> UPDATE member SET name=‘홍길동’ WHERE member_id=1;
> 쿼리가 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일은 변경되고, 언두 영역에 이전 데이터가 백업된다.

트랜잭션이 장시간 유지되는 것은 성능상 좋지 않기에 undo 로그를 항상 모니터링한다.

Undo 로그가 저장되는 공간을 Undo Tablespace라고 한다. 하나의 undo tablespace는 1개 이상 128개 이하의 롤백 새그먼트를 가지며, 롤백 새그먼트는 1개 이상의 언두 슬록이 된다.

### 체인지 버퍼

1. RDBMS에서 Insert나 update시 데이터 파일 뿐만 아니라 인덱스도 같이 업데이트해야 한다.
2. 인덱스 업데이트는 랜덤하게 디스크를 읽는 작업이 필요하여 많은 자원이 소모된다.
3. 버퍼 풀에 없다면 디스크로 읽어와야 한다면 이를 즉시 실행하지 않고 임시공간에 저장해두고 사용자에게 결과를 바로 반환하면 성능 향상이 있다.

이 때 사용하는 임시 메모리 공간을 Change Buffer라고 한다.

- 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
- 체인지 버퍼에 임시저장된 인덱스 레코드 조각은 이후 백그라운드 스레드인 체인지 버퍼 머지 스레드에 의해 병합된다.

### 리두 로그 및 로그 버퍼

대부분의 dbms 서버는 데이터 변경 내용을 로그로 먼저 기록한다.(대부분 쓰기보다 읽기 성능을 고려한 구조를 가졌기 때문)

그래서 변경된 데이터를 데이터 파일에 저장하는 것은 상대적으로 큰 비용이 발생한다.

이로 인한 성능 저하를 막기 위해 데이터베이스 서버는 쓰기 비용이 낮은 자료구조를 가진 리두 로그를 가지고 있다.

리두 로그는 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화돼있다. MySQL 서버에서 트랜잭션이 커밋돼도 데이터 파일은 즉시 디스크로 동기화되지 않는 반면, 리두 로그는 항상 디스크로 기록된다.

### 어댑티브 해시 인덱스

일반적인 인덱스: 사용자가 테이블에 생성해둔 B-Tree 인덱스

- B-Tree 인덱스가 특정 값을 찾는 과정은 시스템 입장에서 느리다!
  (최종 리프 노드까지 가야되기 때문)

어댑티브 해시 인덱스: innoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스

- B-Tree 검색 시간을 줄여주기 위해 도입된 기능
- InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요 시에 인덱스를 검색해서 레코드가 저장된 페이지에 즉시 찾아갈 수 있다.
- 해시 인덱스는 인덱스 키 값과 데이터 페이지 주소의 쌍으로 관리된다.
- 인덱스 키 값은 B-Tree 인덱스의 고유 id와 B-Tree 인덱스의 실제 키 값 조합으로 생성된다.

> **어댑티브 해시 인덱스 기능을 사용하는 것이 꼭 좋을까?**

- 확실히 쿼리 처리 속도와 비용이 많이 감소한다.
- 다만, 어댑티브 해시 인덱스는 데이터 페이지를 메모리 내에서 접근하는 것을 더 빠르게 하기에 데이터 페이지를 디스크에서 매번 읽어온다면 아무런 도움이 되지 않는다.
- 어댑티브 해시 인덱스는 상당히 큰 메모리 공간을 사용할 수도 있다.
- 테이블 삭제나 변경 시 InnoDB는 이 테이블이 가진 모든 데이터 페이지 내용을 어댑티브 해시 인덱스에서 제거해야 함 → 리소스 소요
  >

⇒ 결국 MySQL 서버의 상태값들을 보고 해시 인덱스 히트율에 따라 활성화 비활성화 여부를 확인할 수 있다.

### InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

InnoDB 짱짱

# 3. MyISAM 스토리지 엔진 아키텍처

### 키 캐시

MyISAM의 키 캐시(키 버퍼)는 InnoDB의 버퍼 풀과 비슷한 역할을 한다. 하지만 이름 그대로 키 캐시는 인덱스만을 대상으로 작동한다.

### 운영체제의 캐시 및 버퍼

MyISAM 테이블의 인덱스는 디스크 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능도 MyISAM 스토리지 엔진은 가지고 있지 않기에 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청된다.

### 데이터 파일과 Primary key(인덱스) 구조

InnoDB 스토리지 엔진을 사용하는 테이블은 primary key에 의해서 클러스터링되어 저장되는 반면, MyISAM 테이블은 primary key에 의한 클러스터링 없이 데이터 파일이 Heap 공간처럼 활용된다.(테이블 안에 레코드는 모두 ROWID라는 물리적인 주솟값을 갖고, primary key는 ROWID 값을 포인터로 갖는다)

# 4. MySQL 로그 파일

로그 파일을 통해 MySQL 서버의 상태나 부하의 원인을 쉽게 찾아 해결할 수 있다!

### 에러 로그 파일

MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일(위치: my.cnf에서 log_error라는 이름의 파라미터로 정의된 경로)

- MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
- 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
- 비정상적으로 종료된 커넥션 메시지
- InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지
- MySQL의 종료 메시지

### 제너럴 쿼리 로그 파일(General log)

MySQL 서버에서 실행되는 쿼리 목록 뽑기

→ 쿼리 로그 활성화 이후 로그 파일을 검토한다.

재너럴 쿼리 로그는 슬로우 쿼리 로그와는 다르게 MySQL이 쿼리 요청을 받으면 바로 기록하기 때문에 쿼리 실행중에 에러가 발생해도 일단 로그 파일에 기록된다.

### 슬로우 쿼리 로그

슬로우 쿼리 로그 파일은 MySQL이 쿼리를 실행한 후, 실제 소요된 시간을 기준으로 long_query_time 시스템 변수에 설정한 시간을 초과한 경우 작성된다.
