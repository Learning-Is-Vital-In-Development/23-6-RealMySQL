# 8. 인덱스

생성일: 2023년 4월 16일 오전 10:38

## 8.1 디스크 읽기 방식

<aside>
💡 데이터베이스의 성능 튜닝은 어떻게 디스크의 I/O를 줄이느냐가 관건일 때가 상당히 많다.

</aside>

### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- 기계식 하드 디스크 드라이브의 느린 속도를 대체하기 위해 전자식 저장매체인 SSD가 많이 출시되고 있다.
- 요즘은 DBMS용으로 사용할 서버에는 대부분 SSD를 채택하고 있다.
- 순차 I/O는 SSD나 HDD가 비슷하지만, 랜덤I/O는 SSD가 훨씬 빠르다. DBMS는 대부분 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업을 수행한다.

### 8.1.2 랜덤 I/O와 순차 I/O

- 순차 I/O는 한 번의 시스템 콜을 요청하지만, 랜덤 I/O는 여러 번의 시스템 콜을 요청한다. 만약 HDD라면 디스크를 3번 움직여야 한다는 뜻이다.
- SSD 또한 랜덤 I/O가 순차 I/O보다는 성능이 떨어진다.

> **따라서 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이목적이라고 할 수 있다.**

## 8.2 인덱스란?

<aside>
💡 **데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.**

</aside>

- 컬럼(or 컬럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들고, 컬럼의 값을 정렬한다.
- DBMS의 인덱스는 SortedList처럼 항상 정렬되어 있고, 데이터 파일은 ArrayList처럼 순서대로 저장한다.
- 인덱스가 많은 테이블은 데이터가 저장될 때마다 항상 정렬해야 하므로 느리지만, 아주 빨리 값을 찾아올 수 있다.
- 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장속도를 희생하는 만큼 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정된다.
- 따라서 WHERE 조건절에 사용되는 컬럼이라고 모두 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러온다.

데이터 저장 방식(알고리즘)별 인덱스

- B-Tree 인덱스 알고리즘
  - 가장 일반적으로 사용되는 인덱스 알고리즘
  - 칼럼의 값을 변경하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
- Hash 인덱스 알고리즘
  - 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로 빠른 검색을 지원
  - 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없음
  - 메모리 기반 데이터베이스에서 많이 사용

## 8.3 B-Tree 인덱스

- 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가정 먼저 도입된 알고리즘
- B의 약자는 Binary가 아니라 Balanced이다.

### 8.3.1 구조 및 특성

- 루트 노드: 최상위 노드
- 브랜치 노드: 중간 노드
- 리프 노드: 최하위 노드

인덱스와 실제 데이터가 저장된 데이터는 따로 관리한다. 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

- 데이터 파일의 레코드는 항상 INSERT된 순서로 저장되는 것은 아니다.
- 인덱스는 테이블의 키 컬럼만 가지고 있기에 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
- InnoDB 테이블은 primary 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다. 따라서 인덱스를 통해 레코드를 읽을 때 pk 값을 이용해 pk 인덱스를 한 번 더 검색한 후, pk 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생함

- **인덱스 키 추가**

1. 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색
2. 만약 리프 노드가 꽉 차면 리프 노드가 분리돼야 함
3. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장

> 테이블에 레코드를 추가하는 작업의 비용이 1이라 가정하면 테이블의 인덱스에 키를 추가하는 작업은 1.5정도 예측할 수 있다. 이 작업은 대부분 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 해서 시간이 걸린다.
> ex) 테이블에 인덱스가 3개라면 1 + 1.5\*3 = 5.5

- **인덱스 키 삭제**

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제 마크만 하면 된다.

삭제 마킹된 인덱스 키 공간은 방치하거나 재활용 가능하다.

마킹 작업은 디스크 쓰기가 필요하므로 시간이 걸리기에 버퍼링되에 지연 처리할 수 있다.

- **인덱스 키 변경**

인덱스의 키 값에 따라 리프 노드의 위치가 결정되므로, 인덱스 키 값을 변경하려면 기존 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리된다.

이 작업은 체인지 버퍼를 활용해 지연 처리될 수 있다.

- **인덱스 키 검색**

트리 탐색: 루트 노드부터 시작해 리프 노드까지 이동하면서 비교 작업을 수행하는 과정

인덱스 트리 탐색은 SELECT뿐만 아니라 UPDATE나 DELETE를 처리할 때도 사용된다.

B-Tree 인덱스를 이용한 검색은 100% 일치 or 값의 앞부분만 일치하는 경우에 사용할 수 있다.

> InnoDB 테이블이 지원하는 레코드 잠금이나 넥스트 키락은 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있기에 UPDATE나 DELETE 문장이 실행될 때 테이블에 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

B-Tree 인덱스는 인덱스를 구성하는 컬럼의 크기와 레코드의 건수, 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

- **인덱스 키 값의 크기**

> **Page or Block**: InnoDB 스토리지 엔진의 디스크에 데이터를 저장하는 가장 기본 단위
> (페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다)

⇒ 인덱스 또한 페이지 단위로 관리된다!

B-Tree의 자식 노드 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.

만약 페이지 크기가 16KB이고(default), 인덱스의 키가 16바이트, 자식 노드 주소가 12바이트라면 한 페이지에 585개의 키를 저장할 수 있다.

만약 인덱스 키 값이 커져 32바이트로 늘어나면 372개의 키를 저장할 수 있다. 이 뜻은 만약 SELECT 쿼리가 레코드 500개를 읽어야 한다면 후자는 최소 2번 이상 디스크로부터 읽어야 한다는 뜻이다.

- **B-Tree 깊이**

인덱스 키 값의 크기가 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라도 B-Tree의 깊이가 깊어져 디스크 읽기가 더 많이 필요하게 된다.

- **선택도(기수성)**

Selectivity or Cardinality: 모든 인덱스 키 값 가운데 유니크한 값의 수
ex) 100개의 인덱스 키 값 가운데 유니크한 값의 수는 10개라면 기수성은 10이다.

인덱스는 선택도가 높을수록 검색 대상이 줄어들기에 그만큼 빠르게 처리된다. 예를 들면 아래와 같다.

> **10000개의 레코드가 존재하는 테이블**
> **- 어떤 컬럼의 유니크 값이 10개일 때**(만 개의 레코드엔 10개의 서로 다른 값이 들어있는 것)
> MySQL 서버는 인덱스된 컬럼의 전체 레코드의 건수나 유니크한 값의 개수 등에 대한 통계 정보를 가지고 있다. 따라서 country==”SEOUL”이라 가정하면 서울 컬럼이 평균 10000/10개 존재할거라 예상할 수 있고, 1000건을 검색한다. 결과적으로 999건의 불필요한 정보를 읽을 수 있다.
> **- 어떤 컬럼의 유니크한 값이 1000개일 때**
> 9건의 불필요한 정보만 읽게 된다.

- **읽어야 하는 레코드의 건수**

만약 100만건의 레코드 중 50만건을 읽어야 하는 쿼리가 있다면, 전체 테이블을 모두 읽고 필요없는 50만 건을 버리는게 좋을지, 인덱스를 통해 필요한 50만 건만 읽어 오는 것이 효율적일지 판단해야 한다.

일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드를 한 건 읽는 것보다 4~5배 비용이 더 많이 드는 작업으로 예측한다.

따라서 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%가 넘으면 테이블을 모두 직접 읽어서 필터링한다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

- **인덱스 레인지 스캔**

인덱스의 접근 방법 가운데 가장 대표적인 접근 방법

> SELECT \* FROM employees WHERE first_name BETWEEN ‘Ebbe’ AND ‘Gad’;

인덱스 레인지 스캔은 **검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식**

인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어와야 하기에 한 건 한 건이 랜덤 I/O가 된다.(따라서 인덱스를 통한 레코드 읽기가 4~5배 느린 것)

인덱스 레인지 스캔 요약

1. 인덱스에서 조건을 만족하는 값이 저장된 위치 찾기(인덱스 탐색)
2. 1번에서 탐색한 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽기(인덱스 스캔)
3. 2번에서 읽은 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어옴

- **인덱스 풀 스캔**

인덱스의 처음부터 끝까지 모두 읽는 방식이다.

대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 사용된다.

인덱스 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않는다.

- **루스 인덱스 스캔**

인덱스 레인지 스캔과 비슷하지만, 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.

일반적으로 GROUP BY 또는 집합 함수 가운데 MAX나 MIN 함수에 대해 최적화를 하는 경우에 사용된다.(중간 인덱스가 필요치 않은 이유는 group by로 묶을 것이기 때문)

- **인덱스 스킵 스캔**

만약 두 번째 이후의 인덱싱된 컬럼만 조건으로 사용할 때 원래라면 인덱스 풀 스캔으로 전부 가져와야 하지만, 8.0 버전부터는 옵티마이저가 인덱스 스킵 스캔 최적화 기능을 도입하여 손쉽게 가져올 수 있게 됐다.

인덱스 스킵 스캔은 새로이 도입된 기능이어서 아직 단점이 있다.

- WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함(레인지 스캔 시작 지점을 검색하는 작업이 많아짐)
- 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 함

### 8.3.5 **다중 컬럼 인덱스**

> 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 순서가 중요하다. 인덱스의 두 번째 이상의 컬럼은 그 앞의 컬럼에 의존해서 정렬되기에 이 컬럼은 의미가 없어지는 것이다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 정렬할 때 오름차순으로 정렬해도, 아래부터 읽으면 내림차순으로 읽을 수 있다.

인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.

역순으로 인덱스를 읽는 것은 정순으로 읽는 것보다 28.9% 느리다. 따라서 내림차순으로 읽는 쿼리가 많다면, 내림차순으로 인덱스를 정렬하는 것이 효과적일 것이다.

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

- 비교 조건의 종류와 효율성

다중 컬럼 인덱스에서 각 컬럼의 순서와 그 컬럼에 사용된 조건이 동등 비교인지, 범위 조건인지에 따라 각 인덱스 컬럼의 활용 형태가 달라지며, 그 효율도 달라진다.

- 인덱스의 가용성

B-Tree 인덱스의 특징은 왼쪽 값의 기준으로 오른쪽 값이 정렬되기에 이 특성을 잘 알아야 한다.

만약 LIKE “%mer”의 조건이 있다면 이 쿼리는 인덱스를 이용할 수 없다. 값이 왼쪽을 기준으로 정렬됐기 때문이다.

- 가용성과 효율성 판단

쿼리의 조건에 따라 인덱스를 사용할 수 있는지 없는지 판단 기준이 나와 있음(251~253p 참조)

## 8.4 R-Tree 인덱스

<aside>
💡 Rectangle의 R + B-Tree의 합성어로 MBR을 B-Tree 형태로 구현한 인덱스이다.
MBR: Minimum Bounding Rectangle의 약자로 해당 도형을 감싸는 최소 크기의 사각형을 의미한다.

</aside>

- R-Tree 인덱스의 용도

일반적으로 GPS 기준의 위도, 경도 좌표 등 좌표 시스템에 기반한 정보에 대해 사용된다.

## 8.5 전문 검색 인덱스

B-Tree 인덱스는 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능하다. 전문 검색 인덱스는 문서 전체에 대한 분석과 검색을 위한 전문 검색 알고리즘을 제공하는 인덱스이다.

전문 검색 인덱스는 여러 전문 검색 알고리즘에 따라 나뉜다.

- 어근 분석 알고리즘
- n-gram 알고리즘

### 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 반드시 다음 두 가지 조건을 갖춰야 한다.

- 쿼리 문장이 전문 검색을 위한 문법(MATCH, AGAINST)을 사용
- 테이블 전문 검색 대상 컬럼에 대해서 전문 인덱스 보유
  (FULLTEXT KEY fx_docbody (doc_body) WITH PARSER ngram)

## 8.6 함수 기반 인덱스

<aside>
💡 컬럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축할 경우 함수 기반의 인덱스를 활용한다.
(함수 기반 인덱스는 인덱싱할 값을 계산하는 과정의 차이 뿐이지 실제 인덱스 내부구조 및 유지관리 방법은 B-Tree와 동일)

</aside>

함수 기반 인덱스 구현 방법

- 가상 컬럼을 이용한 인덱스
- 함수를 이용한 인덱스

## 8.7 멀티 벨류 인덱스

<aside>
💡 **하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스**

</aside>

일반적인 RDBMS의 관점에서는 정규화에 위배되지만, 최근의 RDBMS들이 JSON 데이터 타입을 지원하면서 JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생한 것이다.

## 8.8 클러스터링 인덱스

<aside>
💡 테이블의 pk에만 적용되는 인덱스이다.

</aside>

## 8.9 유니크 인덱스

<aside>
💡 MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없기에 유니크 인덱스를 사용한다.

</aside>

- 유니크 인덱스를 사용한다고 성능이 더 좋아지진 않는다.

## 8.10 외래키

MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성된다.

외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.

InnoDB의 외래키 관리의 중요한 두 가지 특징

1. 테이블의 변경(쓰기 잠금)이 발생한 경우에 잠금 경합(잠금 대기)이 발생한다.
2. 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.

데이터베이스에서 외래 키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 모델링을 진행하는 것이 좋다.

잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미친다.
