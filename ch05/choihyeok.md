# 5. 트랜잭션과 잠금

생성일: 2023년 4월 16일 오전 10:38

<aside>
💡 **트랜잭션: 작업의 완전성을 보장한다.**
논리적인 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능
**격리 수준: 하나의 트랜잭션 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨**

</aside>

## 5.1 트랜잭션

MyISAM이나 MEMORY같은 트랜잭션 미지원 스토리지 엔진의 테이블이 더 많은 고민거리를 만들어 낸다.

### 5.1.1 MySQL에서의 트랜잭션

```sql
CREATE TABLE tab_myisam
( fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=MyISAM;
INSERT INTO tab_myisam (fdpk) VALUES (3);

CREATE TABLE tab_innodb
( fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE=INNODB;
INSERT INTO tab_innodb (fdpk) VALUES (3);

// 만약 아래 쿼리를 실행한다면 pk 3이 중복되어 두 table 모두 
// 오류가 발생하지만 myisam은 1, 2가 저장된다.
// (innodb는 1, 2가 저장되지 않는다)
INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
```

MyISAM 스토리지 엔진을 사용할 때 위 정합성 문제를 해결하려면 if문을 사용해야 하지만, innodb는 그럴 필요가 없다.

### 5.1.2 주의사항

트랜잭션의 범위를 최소화하는 것이 좋다!

> 1) 처리 시작(BEGIN 명령어로)
⇒ 데이터베이스 커넥션 생성
⇒ 트랜잭션 시작
2) 사용자의 로그인 여부 확인
3) 사용자의 글쓰기 내용의 오류 여부 확인
4) 첨부로 업로드된 파일 확인 및 저장
5) 사용자의 입력 내용을 DBMS에 저장
6) 첨부 파일 정보를 DBMS에 저장
7) 저장된 내용 또는 기타 정보를 DBMS에서 조회
8) 게시물 등록에 대한 알림 메일 발송
9) 알림 메일 발송 이력을 DBMS에 저장
<=트랜잭션 종료
<=데이터베이스 커넥션 반납
10) 처리 완료
> 

만약 위 작업을 한 트랜잭션 안에서 수행한다면?

- 데이터베이스 커넥션 풀이 매마른다
- FTP 파일 전송 작업이나 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 DBMS의 트랜잭션에 포함시킬 필요는 없다.(통신이 망가지면 DBMS 서버까지 위험해진다)
- 4번부터 트랜잭션 시작 ~ 6번에서 종료, (9)로 쪼개자

## 5.2 MySQL 엔진의 잠금

MySQL 엔진 레벨의 잠금: 모든 스토리지 엔진에 영향을 미침

- 테이블 락: 테이블 데이터 동기화를 위해 건다.
- 메타데이터 락: 테이블의 구조를 잠근다.
- 네임드 락: 사용자의 필요에 맞게 사용할 수 있다.

스토리지 엔진 레벨의 잠금: 스토리지 엔진 간 상호 영향을 미치지 않는다.

### 5.2.1 글로벌 락

<aside>
💡 MySQL에서 제공하는 가장 범위가 큰 락(MySQL 서버 전체 영향)

</aside>

- 명령어: FLUSH TABLES WITH READ LOCK
- 한 세션에서 글로벌 락 획득 시 다른 세션의 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 대기 상태
- 글로벌 락을 획득하려면 먼저 실행된 트랜잭션이 완료될 때까지 기다려야 함
- MyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때 사용
- 8.0부터 InnoDB가 기본 스토리지로 채택되면서 Xtrabackup이나 Enterprise Backup과 같은 백업 락이 도입됨

### 5.2.2 테이블 락

<aside>
💡 개별 테이블 단위로 설정되는 잠금(명시적, 묵시적 락)

</aside>

- 명시적: LOCK TABLES table_name [READ | WRITE]
    - 테이블 락은 MyISAM뿐 아니라 InnoDB도 동일하게 설정한다.
    - 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미친다.
- 묵시적
    - MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생함(쿼리가 실행되는 동안 자동으로 획득됐다가 완료되면 해제)
    - InnoDB 테이블은 엔진 차원에서 레코드 기반의 잠금을 제공하기에 DDL에만 테이블 락 걸림(DML은 무시, DDL만 영향을 미친다)

### 5.2.3 네임드 락

<aside>
💡 GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금

</aside>

- 네임드 락은 테이블이나 레코드같은 db 객체가 아닌 사용자가 지정한 String에 대해 획득하고 반납한다.
- SELECT GET_LOCK(’mylock’, 2): mylock이라는 문자열에 대해 잠금을  획득하고, 이미 잠금을 사용 중이면 2초 동안만 대기한다.
- SELECT IS_FREE_LOCK(’mylock’): mylock이라는 문자열에 대해 잠금이 설정돼 있는지 확인한다.
- SELECT RELEASE_LOCK(’mylock’): mylock이라는 문자열에 대해 획득했던 잠금을 반납한다.
- 많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용된다.

### 5.2.4 메타데이터 락

<aside>
💡 데이터베이스 객체(테이블이나 뷰)의 이름이나 구조를 변경하는 경우 획득하는 잠금

</aside>

- 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금
- 명시적으로 획득하거나 해제할 수 있는 것이 아닌 자동으로 획득함

## 5.3 InnoDB 스토리지 엔진 잠금

- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에 레코드 기반의 잠금 방식을 탑재함
- InnoDB에 사용되는 잠금에 대한 정보는 MySQL 명령을 통해 접근하기 까다로움(이원화된 잠금 탓) → 최근 버전은 문제 해결됨

### 5.3.1 InnoDB 스토리지 엔진의 잠금

<aside>
💡 **레코드 기반의 잠금 기능 제공**
잠금 정보가 상당히 작은 공간으로 관리되기에 레코드 락이 페이지 락 또는 테이블 락으로 레벨업 되는 경우는 없다

</aside>

- **레코드 락**
    - 레코드 자체만 잠그는 락으로 인덱스의 레코드를 잠근다.(인덱스가 없더라도 자동생성된 클러스터 인덱스를 이용해 잠금을 설정함)
    - 레코드 자체를 잠그는 것과 인덱스를 잠그는 것은 중요한 차이이다.
- **갭 락**
    - 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만 잠근다.
    - 레코드와 레코드 사이에 새로운 레코드가 생성되는 것을 제어한다.
    - 넥스트 키 락의 일부로 자주 사용된다.
- **넥스트 키 락**
    - 레코드 락 + 갭 락
- **자동 증가 락**
    - AUTO_INCREMENT: 자동으로 pk 값을 증가하여 저장
    - 여러 레코드가 저장되는 경우 중복되지 않고 저장된 순서대로 증가하는 인련번호 값을 가져야 하기에 자동으로 내부적으로 auto increment lock을 사용
    - INSERT, REPLACE같이 새로운 레코드를 저장하는 쿼리에만 필요함

### 5.3.2 인덱스와 잠금

> SELECT COUNT(*) FROM employees WHERE first_name = ‘choi’
> 

MySQL은 레코드를 업데이트할 때 first_name 컬럼에 인덱스가 없다면  first_name 컬럼 전체가 잠기는 방식을 채택했다. 그렇기에 테이블에 인덱스를 잘 설계하자

### 5.3.3 레코드 수준의 잠금 확인 및 해제

레코드 수준의 잠금은 테이블 수준의 잠금보다 더 복잡한데 이유는 잘 안 사용하는 레코드는 오랜 시간 동안 잠겨있어도 잘 발견되지 않는다.

- 프로세스 목록 조회
    - SHOW PROCESSLIST
        
- performance_schema의 테이블을 이용한 잠금과 잠금 대기 순서 확인 방법
    - performance_schema.data_lock_waits와 performance_schema.data_locks 조인해서 잠금 대기순서를 확인할 수 있다.
- 만약 17번 스레드가 오랜 시간 잠겨있다면 17번 스레드를 강제 종료하면 나머지 명령들이 진행되며서 잠금 경합이 끝난다.

## 5.4 MySQL의 격리 수준

<aside>
💡 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지를 결정

</aside>

|  | DIRTY READ | NON-REPEATABLE READ | PHANTOM READ |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | 없음 | 발생 | 발생 |
| REPEATABLE READ | 없음 | 없음 | 발생
(InnoDB는 없음) |
| SERIALIZABLE | 없음 | 없음 | 없음 |
- REPEATABLE READ 격리 수준에서는 THANTOM READ가 발생할 수 있지만, InnoDB에서는 독특한 특성 때문에 발생하지 않는다
- 보통 READ COMMITTED와 REPEATABLE READ중 하나를 사용한다.

### 5.4.1 READ UNCOMMITTED

<aside>
💡 **더티 리드가 허용되는 격리 수준**

</aside>

> **DIRTY READ**: 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상
> 
- 더티 리드 현상은 데이터가 나타났다가 사라졌다 하는 현상을 초래한다.
- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.
- MySQL을 사용한다면 최소한 READ COMMITTED 이상을 사용하자

### 5.4.2 READ COMMITTED

<aside>
💡 **오라클 DBMS에서 기본으로 사용하는 격리 수준으로 더티 리드를 허용하지 않음. NON-REPEATABLE READ라는 부정합 문제 존재**

</aside>

> **NON-REPEATABLE READ:** 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 REPEATABLE READ 정합성을 어긴 것
> 
- 만약 커밋 안 된 트랜잭션 안의 데이터를 읽을 때는, 데이터 변경 전인 언두 로그 데이터를 읽는다.
- 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결된다면 문제가 될 수도 있다.

### 5.4.3 REPEATABLE READ

<aside>
💡 **MySQL의 InnoDB 스토리지 엔진의 기본 격리 수준으로 NON-REPEATABLE READ 부정합이 발생하지 않음**

</aside>

- 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함돼 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB가 불필요하다고 판단하는 시점에 주기적으로 삭제한다.

### 5.4.4 SERIALIZABLE

<aside>
💡 **한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없음**

</aside>

- InnoDB는 갭 락과 넥스트 키 락 덕분에 REPEATABLE READ 격리 수준에서도 이미 PHANTOM READ가 발생하지 않기 때문에 굳이 사용하지 않아도 된다.